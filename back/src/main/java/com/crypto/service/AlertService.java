package com.crypto.service;

import com.crypto.model.AlertRule;
import com.crypto.dto.CryptoCurrency;
import com.crypto.model.User;
import com.crypto.model.dto.NotificationMessage;
import com.crypto.repository.AlertRuleRepository;
import com.crypto.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.util.List;
import java.util.Optional;

@Slf4j
@Service
@RequiredArgsConstructor
public class AlertService {

    private final AlertRuleRepository alertRuleRepository;
    private final NotificationService notificationService;
    private final UserRepository userRepository;

    private final DecimalFormat df = new DecimalFormat("#,##0.00");

    /**
     * ‚úÖ CORRE√á√ÉO: Processa alertas APENAS para um usu√°rio espec√≠fico
     */
    public void processAlertsForUser(List<CryptoCurrency> cryptos, String userEmail) {
        log.info("üîç Processando alertas para email: {}", userEmail);

        int alertsChecked = 0;
        int alertsTriggered = 0;

        for (CryptoCurrency crypto : cryptos) {
            try {
                // ‚úÖ CORRE√á√ÉO: Normalizar s√≠mbolo para UPPERCASE
                String normalizedSymbol = crypto.getSymbol().toUpperCase();

                log.debug("üìä Verificando {} | Symbol API: {} | Normalizado: {}",
                        crypto.getName(), crypto.getSymbol(), normalizedSymbol);

                // Busca apenas alertas ATIVOS deste email para esta crypto
                List<AlertRule> rules = alertRuleRepository
                        .findByCoinSymbolAndNotificationEmailAndActiveTrue(
                                normalizedSymbol,  // ‚úÖ USA UPPERCASE
                                userEmail
                        );

                alertsChecked += rules.size();

                log.debug("üîî Encontrados {} alertas para {} (email: {})",
                        rules.size(), normalizedSymbol, userEmail);

                for (AlertRule rule : rules) {
                    try {
                        if (shouldTriggerAlert(crypto, rule)) {
                            triggerAlert(crypto, rule);
                            alertsTriggered++;
                        }
                    } catch (Exception e) {
                        log.error("Erro ao verificar regra {} para {} (usu√°rio: {}): {}",
                                rule.getId(), normalizedSymbol, userEmail, e.getMessage());
                    }
                }

            } catch (Exception e) {
                log.error("Erro ao processar {} para {}: {}",
                        crypto.getSymbol(), userEmail, e.getMessage());
            }
        }

        log.info("‚úÖ Processamento conclu√≠do para {}: {} alertas verificados, {} disparados",
                userEmail, alertsChecked, alertsTriggered);
    }

    /**
     * ‚úÖ CORRE√á√ÉO: L√≥gica de verifica√ß√£o CORRIGIDA
     */
    private boolean shouldTriggerAlert(CryptoCurrency crypto, AlertRule rule) {
        BigDecimal threshold = rule.getThresholdValue();

        switch (rule.getAlertType()) {
            case PRICE_INCREASE:
                return crypto.getCurrentPrice() != null &&
                        crypto.getCurrentPrice().compareTo(threshold) >= 0;

            case PRICE_DECREASE:
                return crypto.getCurrentPrice() != null &&
                        crypto.getCurrentPrice().compareTo(threshold) <= 0;

            case VOLUME_SPIKE:
                return crypto.getTotalVolume() != null &&
                        crypto.getTotalVolume().compareTo(threshold) >= 0;

            case PERCENT_CHANGE_24H:
                if (crypto.getPriceChange24h() == null) {
                    return false;
                }

                double priceChange = crypto.getPriceChange24h();
                double thresholdValue = threshold.doubleValue();

                // ‚úÖ CORRE√á√ÉO: Log detalhado para DEBUG
                log.debug("üîç {} | Varia√ß√£o: {}% | Threshold: {}% | Tipo: {}",
                        crypto.getSymbol(),
                        String.format("%.2f", priceChange),
                        String.format("%.2f", thresholdValue),
                        thresholdValue < 0 ? "QUEDA" : "ALTA");

                // ‚úÖ CORRE√á√ÉO: Threshold NEGATIVO ‚Üí Alerta de QUEDA
                if (thresholdValue < 0) {
                    // Exemplo: threshold = -0.5
                    // Se priceChange = -0.6 ‚Üí -0.6 <= -0.5 ‚Üí TRUE ‚úÖ
                    // Se priceChange = -0.4 ‚Üí -0.4 <= -0.5 ‚Üí FALSE ‚úÖ
                    boolean triggered = priceChange <= thresholdValue;

                    if (triggered) {
                        log.info("üìâ ALERTA DE QUEDA DISPARADO: {} caiu {}% (threshold: {}%)",
                                crypto.getSymbol(),
                                String.format("%.2f", priceChange),
                                String.format("%.2f", thresholdValue));
                    } else {
                        log.debug("‚ö™ {} n√£o atingiu threshold de queda: {}% > {}%",
                                crypto.getSymbol(),
                                String.format("%.2f", priceChange),
                                String.format("%.2f", thresholdValue));
                    }

                    return triggered;
                }

                // ‚úÖ CORRE√á√ÉO: Threshold POSITIVO ‚Üí Alerta de ALTA
                else if (thresholdValue > 0) {
                    // Exemplo: threshold = 0.5
                    // Se priceChange = 0.6 ‚Üí 0.6 >= 0.5 ‚Üí TRUE ‚úÖ
                    // Se priceChange = 0.4 ‚Üí 0.4 >= 0.5 ‚Üí FALSE ‚úÖ
                    boolean triggered = priceChange >= thresholdValue;

                    if (triggered) {
                        log.info("üìà ALERTA DE ALTA DISPARADO: {} subiu {}% (threshold: {}%)",
                                crypto.getSymbol(),
                                String.format("%.2f", priceChange),
                                String.format("%.2f", thresholdValue));
                    } else {
                        log.debug("‚ö™ {} n√£o atingiu threshold de alta: {}% < {}%",
                                crypto.getSymbol(),
                                String.format("%.2f", priceChange),
                                String.format("%.2f", thresholdValue));
                    }

                    return triggered;
                }

                return false;

            case MARKET_CAP:
                return crypto.getMarketCap() != null &&
                        crypto.getMarketCap().compareTo(threshold) >= 0;

            default:
                return false;
        }
    }

    /**
     * Dispara o alerta enviando notifica√ß√£o
     */
    private void triggerAlert(CryptoCurrency crypto, AlertRule rule) {
        String message = buildAlertMessage(crypto, rule);

        NotificationMessage notification = NotificationMessage.builder()
                .coinSymbol(crypto.getSymbol())
                .coinName(crypto.getName())
                .currentPrice("$" + df.format(crypto.getCurrentPrice()))
                .changePercentage(crypto.getPriceChange24h() != null
                        ? String.format("%.2f%%", crypto.getPriceChange24h())
                        : "N/A")
                .alertType(rule.getAlertType())
                .message(message)
                .recipient(rule.getNotificationEmail())
                .build();

        notificationService.sendNotification(notification);

        log.info("üîî Alerta disparado: {} - {} -> {} (Email: {})",
                crypto.getSymbol(), rule.getAlertType(), message, rule.getNotificationEmail());
    }

    /**
     * Constr√≥i a mensagem do alerta
     */
    private String buildAlertMessage(CryptoCurrency crypto, AlertRule rule) {
        switch (rule.getAlertType()) {
            case PRICE_INCREASE:
                return String.format(
                        "üöÄ %s (%s) atingiu $%s (limite $%s). Varia√ß√£o 24h: %.2f%%",
                        crypto.getName(),
                        crypto.getSymbol().toUpperCase(),
                        df.format(crypto.getCurrentPrice()),
                        df.format(rule.getThresholdValue()),
                        crypto.getPriceChange24h() != null ? crypto.getPriceChange24h() : 0
                );

            case PRICE_DECREASE:
                return String.format(
                        "üìâ %s (%s) caiu para $%s (limite $%s). Varia√ß√£o 24h: %.2f%%",
                        crypto.getName(),
                        crypto.getSymbol().toUpperCase(),
                        df.format(crypto.getCurrentPrice()),
                        df.format(rule.getThresholdValue()),
                        crypto.getPriceChange24h() != null ? crypto.getPriceChange24h() : 0
                );

            case VOLUME_SPIKE:
                return String.format(
                        "üìä %s (%s) com volume acima de %s (atual %s)",
                        crypto.getName(),
                        crypto.getSymbol().toUpperCase(),
                        df.format(rule.getThresholdValue()),
                        df.format(crypto.getTotalVolume())
                );

            case PERCENT_CHANGE_24H:
                return String.format(
                        "‚ö° %s (%s) variou %.2f%% nas √∫ltimas 24h (limite: %s%%)",
                        crypto.getName(),
                        crypto.getSymbol().toUpperCase(),
                        crypto.getPriceChange24h(),
                        df.format(rule.getThresholdValue())
                );

            case MARKET_CAP:
                return String.format(
                        "üè¶ %s (%s) com market cap acima de %s (atual %s)",
                        crypto.getName(),
                        crypto.getSymbol().toUpperCase(),
                        df.format(rule.getThresholdValue()),
                        df.format(crypto.getMarketCap())
                );

            default:
                return String.format("%s (%s) - alerta disparado",
                        crypto.getName(), crypto.getSymbol().toUpperCase());
        }
    }

    // ============================================
    // M√âTODOS DE GERENCIAMENTO (Mantidos)
    // ============================================

    public AlertRule createAlertRule(AlertRule alertRule) {
        try {
            Object principal = SecurityContextHolder.getContext().getAuthentication() != null
                    ? SecurityContextHolder.getContext().getAuthentication().getPrincipal()
                    : null;

            if (principal instanceof org.springframework.security.core.userdetails.User) {
                String username = ((org.springframework.security.core.userdetails.User) principal).getUsername();
                Optional<User> u = userRepository.findByUsername(username);
                u.ifPresent(alertRule::setUser);
            }
        } catch (Exception e) {
            log.debug("N√£o foi poss√≠vel vincular usu√°rio √† regra: {}", e.getMessage());
        }

        alertRule.setActive(true);
        AlertRule saved = alertRuleRepository.save(alertRule);
        log.info("‚úÖ Nova regra de alerta criada: {}", saved);
        return saved;
    }

    public List<AlertRule> getActiveAlertRules() {
        return alertRuleRepository.findByActiveTrue();
    }

    public void deactivateAlertRule(Long ruleId) {
        alertRuleRepository.findById(ruleId).ifPresent(rule -> {
            rule.setActive(false);
            alertRuleRepository.save(rule);
            log.info("üõë Regra de alerta {} desativada", ruleId);
        });
    }

    public int deactivateAllAlertsForUser(String userEmail) {
        log.info("üõë Desativando todos os alertas para: {}", userEmail);

        List<AlertRule> userAlerts = alertRuleRepository
                .findByNotificationEmailAndActiveTrue(userEmail);

        int deactivatedCount = 0;
        for (AlertRule rule : userAlerts) {
            rule.setActive(false);
            alertRuleRepository.save(rule);
            deactivatedCount++;
        }

        log.info("‚úÖ {} alertas desativados para {}", deactivatedCount, userEmail);
        return deactivatedCount;
    }

    public void checkAlertsForCrypto(CryptoCurrency crypto) {
        String normalizedSymbol = crypto.getSymbol().toUpperCase();
        List<AlertRule> rules = alertRuleRepository.findByCoinSymbolAndActiveTrue(normalizedSymbol);

        for (AlertRule rule : rules) {
            try {
                if (shouldTriggerAlert(crypto, rule)) {
                    triggerAlert(crypto, rule);
                }
            } catch (Exception e) {
                log.error("Erro ao verificar regra {} para {}: {}",
                        rule.getId(), normalizedSymbol, e.getMessage());
            }
        }
    }

    public void checkAlertsForCryptoAndUser(CryptoCurrency crypto, String userEmail) {
        log.debug("üîç Verificando alertas de {} para {}", crypto.getSymbol(), userEmail);

        String normalizedSymbol = crypto.getSymbol().toUpperCase();

        List<AlertRule> rules = alertRuleRepository
                .findByCoinSymbolAndNotificationEmailAndActiveTrue(
                        normalizedSymbol,
                        userEmail
                );

        if (rules.isEmpty()) {
            log.debug("Nenhum alerta ativo para {} (usu√°rio: {})", normalizedSymbol, userEmail);
            return;
        }

        for (AlertRule rule : rules) {
            try {
                if (shouldTriggerAlert(crypto, rule)) {
                    triggerAlert(crypto, rule);
                    log.info("üîî Alerta disparado: {} para {} (regra: {})",
                            normalizedSymbol, userEmail, rule.getId());
                }
            } catch (Exception e) {
                log.error("Erro ao verificar regra {} para {} (usu√°rio: {}): {}",
                        rule.getId(), normalizedSymbol, userEmail, e.getMessage());
            }
        }
    }

    public List<AlertRule> getActiveAlertRulesForUser(String userEmail) {
        log.debug("üìã Buscando alertas ativos para: {}", userEmail);
        List<AlertRule> rules = alertRuleRepository
                .findByNotificationEmailAndActiveTrue(userEmail);
        log.debug("Encontrados {} alertas ativos para {}", rules.size(), userEmail);
        return rules;
    }

    public List<AlertRule> getAlertRulesForUser(String username) {
        return alertRuleRepository.findAll()
                .stream()
                .filter(r -> r.getUser() != null && username.equals(r.getUser().getUsername()))
                .toList();
    }

    public void processAlerts(List<CryptoCurrency> cryptos) {
        for (CryptoCurrency crypto : cryptos) {
            checkAlertsForCrypto(crypto);
        }
    }
}